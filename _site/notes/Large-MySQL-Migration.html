<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Large MySQL Table Migrations</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@" /><meta name="twitter:title" content="Large MySQL Table Migrations" /><meta name="twitter:description" content="Problem"><meta name="description" content="Problem"><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/notes/Large-MySQL-Migration"><link rel="alternate" type="application/atom+xml" title="Everything JS" href="/feed.xml" /></head><body><aside class="logo"> <a href="/"> <img src="http://i.imgur.com/lXpakuT.jpg?1" class="gravatar" width="80px"> </a> <span class="logo-prompt">Back to Home</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>Large MySQL Table Migrations</h1><time>May 9, 2016</time></div><div class="divider"></div><h2 id="problem">Problem</h2><p>Suppose you have a really large MySQL table, like millions of rows, and you need to make an <code class="highlighter-rouge">ALTER</code> statement that effects all the rows, such as:</p><div class="highlighter-rouge"><pre class="highlight"><code>ALTER TABLE `table_name` ADD COLUMN `new_column_name` varchar(255) NULL DEFAULT NULL;
</code></pre></div><p>And also suppose that this table is being actively queried, what should you be worried about?</p><p>Under the hood MySQL will actually create a temporary table, copy everything over to the temp table, and do some renaming operations to point everything to the newly created table. The copy operation is costly, both in I/O and time. When the table is really large, this can take minutes and hours. This operation will also cause update requests to be put on hold. And it’s likely that whatever server framework you’re running will probably run out of maximum concurrent connections before the query is complete, therefore causing the service to break.</p><h2 id="work-around-1">Work Around 1</h2><p>Use tools! There are tools that helps with exactly these sort of large migrations, but they’re all doing essentially the same thing: 1. Create a new table 1. Create trigger that copies new entries from the existing table to the new table 1. Slowly backfill the existing entries to the new table 1. Once the backfill is complete, rename the new table to the old table 1. Success</p><p>Of course there are some error checking to ensure that no entries are lost, duplicated, or altered.</p><h2 id="work-around-2">Work Around 2</h2><p>Use a seperate table! Create another table that just uses the primary/foreign key relationship to link the new columns of the new table to the entries in the existing table. And use the same backfill strategy as work around 1.</p><p>If the backfilling operation happens all at once or too quickly, you can make queries that immediately follow slower than usual because you will have force cleared the cache with the backfill operations.</p></article><div class="back"> <a href="/">Back</a></div></main></body></html>