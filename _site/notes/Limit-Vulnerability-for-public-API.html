<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Limit Vulnerability For Public API</title><meta name="twitter:card" content="summary" /><meta name="twitter:site" content="@" /><meta name="twitter:title" content="Limit Vulnerability For Public API" /><meta name="twitter:description" content="Suppose you’re making a public-facing full stack application that doesn’t require user logins. This application also references some relational resources via a REST API that you’re designing."><meta name="description" content="Suppose you’re making a public-facing full stack application that doesn’t require user logins. This application also references some relational resources via..."><link rel="icon" href="/assets/favicon.png"><link rel="apple-touch-icon" href="/assets/touch-icon.png"><link rel="stylesheet" href="//code.cdn.mozilla.net/fonts/fira.css"><link rel="stylesheet" href="/assets/core.css"><link rel="canonical" href="/notes/Limit-Vulnerability-for-public-API"><link rel="alternate" type="application/atom+xml" title="Everything JS" href="/feed.xml" /></head><body><aside class="logo"> <a href="/"> <img src="http://i.imgur.com/lXpakuT.jpg?1" class="gravatar" width="80px"> </a> <span class="logo-prompt">Back to Home</span></aside><main> <noscript><style> article .footnotes { display: block; }</style></noscript><article><div class="center"><h1>Limit Vulnerability For Public API</h1><time>May 5, 2016</time></div><div class="divider"></div><p>Suppose you’re making a public-facing full stack application that doesn’t require user logins. This application also references some relational resources via a REST API that you’re designing.</p><p>This situation presents an interesting problem in that the API must be public, and anyone can curl it. So anyone can potentially get, update, or delete resources she/he shouldn’t have access to through the front-end interface. So how do you prevent this?</p><p>One solution is to not expose the database primary key in the URL as resource identifiers, which is typically numerical and auto-incremented. The numerical and auto-incrementing nature makes it extremely easy to guess similar resources.</p><p>For example, an endpoint that returns a resource <code class="highlighter-rouge">data</code> with an identifier of <code class="highlighter-rouge">dataId</code> can look like this:</p><p><code class="highlighter-rouge">/api/data/:dataId</code></p><p>If <code class="highlighter-rouge">dataId</code> is simply the database primary key, and I somehow know that <code class="highlighter-rouge">/api/data/872972</code> exists, then I can just as easily try <code class="highlighter-rouge">/api/data/872973</code> or any other number to access a resource that developers did not intend for me to have access to.</p><p>We can obfusicate the primary key via some sort of hashed string, url_hash, store the url_hash in the database for look up, and serve the resource identifier via this url_hash. So it’s important that this url_hash is unique and have no collisions, or have very low likelihood of collision. It’s also imperative for the purpose of this application that the resulting url_hash has sufficient character length to make it impossible to randomly guess a correct identifier.</p><p>A UUID seems very appropriate here. But do keep in mind that UUIDs to savy programmers are still quite easily guessable. Alternatively, what other hashing methods can we use? Anything else we can do? Maybe choose a different hashing method: SHA512, etc. Maybe also salt the hash.</p><p>The key is that if you make the resource ID difficult to guess, then it is at least one layer of deterrent from malicious users. And it’s not difficult to make something that’s near impossible to guess. A 32 character hex key provides 3.4 * 10^38 possible combinations.</p></article><div class="back"> <a href="/">Back</a></div></main></body></html>